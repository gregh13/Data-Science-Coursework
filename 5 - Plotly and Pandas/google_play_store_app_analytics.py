# -*- coding: utf-8 -*-
"""Google Play Store App Analytics_Day_75

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tva1rVKtfx4FGVe2aXfJIKui3ftACFun

# Introduction

In this notebook, we will do a comprehensive analysis of the Android app market by comparing thousands of apps in the Google Play store.

# About the Dataset of Google Play Store Apps & Reviews

**Data Source:** <br>
App and review data was scraped from the Google Play Store by Lavanya Gupta in 2018. Original files listed [here](
https://www.kaggle.com/lava18/google-play-store-apps).

# Import Statements
"""

import pandas as pd
import plotly.express as px

"""# Notebook Presentation"""

# Show numeric output in decimal format e.g., 2.15
pd.options.display.float_format = '{:,.2f}'.format

"""# Read the Dataset"""

df_apps = pd.read_csv('apps.csv')

"""# Data Cleaning

**Challenge**: How many rows and columns does `df_apps` have? What are the column names? Look at a random sample of 5 different rows with [.sample()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html).
"""

df_apps.head()

df_apps.describe()

# Generates a random sample of n rows
df_apps.sample(5)

"""### Drop Unused Columns

**Challenge**: Remove the columns called `Last_Updated` and `Android_Version` from the DataFrame. We will not use these columns. 
"""

# Two ways to drop columns:
df_apps.pop('Last_Updated')
df_apps.drop(columns=['Android_Ver'], axis=1, inplace=True)
df_apps.head()

"""### Find and Remove NaN values in Ratings

**Challenge**: How may rows have a NaN value (not-a-number) in the Ratings column? Create DataFrame called `df_apps_clean` that does not include these rows. 
"""

nan_rows = df_apps[df_apps.Rating.isna()]
display(nan_rows.shape)
nan_rows.head()

df_apps_clean = df_apps.dropna()

df_apps_clean.describe()

"""### Find and Remove Duplicates

**Challenge**: Are there any duplicates in data? Check for duplicates using the [.duplicated()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.duplicated.html) function. How many entries can you find for the "Instagram" app? Use [.drop_duplicates()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html) to remove any duplicates from `df_apps_clean`. 

"""

# Doesn't capture all the duplicates
duplicated_rows = df_apps_clean[df_apps_clean.duplicated()]
print(duplicated_rows.shape)
duplicated_rows.head()

# This captures all the apps that have the same name (even if their other data is different)
print(df_apps_clean.duplicated(subset='App'))
df_apps_clean[df_apps_clean.duplicated(subset='App') == True]

# Another example of duplicates not caught by .duplicated()
df_apps_clean[df_apps_clean.App == 'Instagram']

df_clean = df_apps_clean.drop_duplicates(subset='App')
df_clean.describe()

"""# Find Highest Rated Apps

**Challenge**: Identify which apps are the highest rated. What problem might you encounter if you rely exclusively on ratings alone to determine the quality of an app?
"""

# Only apps with over 1 million reviews, sorted by rating(descending), then calls top 25
df_clean[df_clean.Reviews > 1000000].sort_values('Rating', ascending=False).head(25)

"""# Find 5 Largest Apps in terms of Size (MBs)

**Challenge**: What's the size in megabytes (MB) of the largest Android apps in the Google Play Store. Based on the data, do you think there could be limit in place or can developers make apps as large as they please? 
"""

df_clean.sort_values('Size_MBs', ascending=False).head(10)

"""# Find the 5 App with Most Reviews

**Challenge**: Which apps have the highest number of reviews? Are there any paid apps among the top 50?
"""

df_clean.sort_values('Reviews', ascending=False).head(50)

"""# Plotly Pie and Donut Charts - Visualise Categorical Data: Content Ratings"""

# Good old value_counts. When you only want to filter by one column and get the counts.
ratings = df_clean.Content_Rating.value_counts()
ratings

# Takes the simple table above, turns it into a pie chart
fig = px.pie(labels=ratings.index, 
             values=ratings.values)
fig.show()

# Add the names(legend) and title
fig = px.pie(names=ratings.index, 
             labels=ratings.index, 
             values=ratings.values, 
             title='Content Rating')
fig.show()

# Use update_traces to change attributes of the pie chart

fig = px.pie(names=ratings.index, 
             labels=ratings.index, 
             values=ratings.values, 
             title='Content Rating')

fig.update_traces(textposition='outside', 
                  textinfo='percent+label')
fig.show()

# Add donut hole parameter, change update_traces styling
fig = px.pie(labels=ratings.index,
             values=ratings.values,
             title="Content Rating",
             names=ratings.index,
             hole=0.6,
             )

fig.update_traces(textposition='inside', textfont_size=15, textinfo='percent')
 
fig.show()

"""# Numeric Type Conversion: Examine the Number of Installs

**Challenge**: How many apps had over 1 billion (that's right - BILLION) installations? How many apps just had a single install? 

Check the datatype of the Installs column.

Count the number of apps at each level of installations. 

Convert the number of installations (the Installs column) to a numeric data type. Hint: this is a 2-step process. You'll have make sure you remove non-numeric characters first. 
"""

# Oddly, sorting this way doesn't show the top installs (Facebook, Instagram, etc.)
# Cause: install data = object, not numerical values that can be sorted

df_clean.sort_values('Installs', ascending=False)

# Two ways to get info about the table specifics
display(df_clean.Installs.describe())
df_clean.info()

# Strange ordering, due to non-numeric values
df_clean[['App','Installs']].groupby('Installs').count()

# First, we replace all the commas with an empty string
# Then we change it to a numeric value
df_clean.Installs = df_clean.Installs.astype(str).str.replace(',', "")
df_clean.Installs = pd.to_numeric(df_clean.Installs)
df_clean[['App', 'Installs']].groupby('Installs').count()

# Now sorting by Installs gives us the expected outcome :D
df_clean.sort_values('Installs', ascending=False)

"""# Find the Most Expensive Apps, Filter out the Junk, and Calculate a (ballpark) Sales Revenue Estimate

Let's examine the Price column more closely.

**Challenge**: Convert the price column to numeric data. Then investigate the top 20 most expensive apps in the dataset.

Remove all apps that cost more than $250 from the `df_apps_clean` DataFrame.

Add a column called 'Revenue_Estimate' to the DataFrame. This column should hold the price of the app times the number of installs. What are the top 10 highest grossing paid apps according to this estimate? Out of the top 10 highest grossing paid apps, how many are games?

"""

# Price column data was also a non-numeric, object value, need to reformat
print(df_clean.info())
# replace dollar sign, change to numeric
df_clean.Price = df_clean.Price.astype(str).str.replace('$', "")
df_clean.Price = pd.to_numeric(df_clean.Price)
df_clean.sort_values('Price', ascending=False).head(50)

"""### The most expensive apps sub $250"""

stupid_expensive_apps = df_clean[df_clean['Price'] > 250]
display(stupid_expensive_apps)
df_cleaner = df_clean.drop(stupid_expensive_apps.index)
display(df_cleaner.describe())
df_cleaner.sort_values('Price', ascending=False)

# Her Way (better):
# df_cleaner = df_clean[df_apps_clean['Price'] < 250]

"""### Highest Grossing Paid Apps (ballpark estimate)"""

est_gross_income = df_cleaner.Installs * df_cleaner.Price
df_cleaner.insert(column='Estimated_Gross', loc=9, value=est_gross_income)
df_cleaner.sort_values('Estimated_Gross', ascending=False).head(25)

# Her Way (uses the .mul to multiply):
# df_cleaner['Revenue_Estimate'] = df_cleaner.Installs.mul(df_cleaner.Price)
# df_cleaner.sort_values('Revenue_Estimate', ascending=False)[:10]

"""# Plotly Bar Charts & Scatter Plots: Analysing App Categories"""

print(f'Number of unique categories: {df_cleaner.Category.nunique()}\n')
df_cleaner.Category.value_counts()

"""### Vertical Bar Chart - Highest Competition (Number of Apps)"""

top_10_categories = df_cleaner.Category.value_counts()[:10]
top_10_categories

bar = px.bar(x=top_10_categories.index, 
             y=top_10_categories.values)
bar.show()

"""### Horizontal Bar Chart - Most Popular Categories (Highest Downloads)"""

# Since not counting num of rows, but the actual number in a row, need to do .agg with .sum
category_installs = df_cleaner.groupby('Category').agg({'Installs':pd.Series.sum})
category_installs.sort_values('Installs', ascending=True, inplace=True)
category_installs

# LOL! NOT useful at all...
# category_installs = df_cleaner.groupby('Installs').agg({'Category':pd.Series.sum})
# category_installs.sort_values('Category', ascending=True, inplace=True)
# category_installs

# Horizontal bar, so the x and y values need to be flipped
h_bar = px.bar(y=category_installs.index, 
               x=category_installs.Installs, 
               orientation='h',
               title='Category Popularity (# of Installs)')
h_bar.show()

# Use update_layout to change the labels and graph
h_bar = px.bar(y=category_installs.index, 
               x=category_installs.Installs, 
               orientation='h',
               title='Category Popularity (# of Installs)')
h_bar.update_layout(xaxis_title='Number of Downloads', yaxis_title='Category')
h_bar.show()

"""### Category Concentration - Downloads vs. Competition

**Challenge**: 
* First, create a DataFrame that has the number of apps in one column and the number of installs in another:

<img src=https://imgur.com/uQRSlXi.png width="350">

* Then use the [plotly express examples from the documentation](https://plotly.com/python/line-and-scatter/) alongside the [.scatter() API reference](https://plotly.com/python-api-reference/generated/plotly.express.scatter.html)to create scatter plot that looks like this. 

<img src=https://imgur.com/cHsqh6a.png>

*Hint*: Use the size, hover_name and color parameters in .scatter(). To scale the yaxis, call .update_layout() and specify that the yaxis should be on a log-scale like so: yaxis=dict(type='log') 
"""

# Create new dataframe with .groupby and .agg with Series sums
category_df = df_cleaner.groupby('Category').agg({'App':pd.Series.count, 'Installs':pd.Series.sum})

category_df.sort_values('Installs', ascending=False, inplace=True)
print(category_df.shape)
category_df

# Her way of making a new DataFrame: make a new single agg Series, then merge the two:
# cat_number = df_cleaner.groupby('Category').agg({'App': pd.Series.count})
# cat_merged_df = pd.merge(cat_number, category_installs, on='Category', how="inner")
# print(f'The dimensions of the DataFrame are: {cat_merged_df.shape}')
# cat_merged_df.sort_values('Installs', ascending=False)

fig = px.scatter(category_df, x='App', y='Installs')

fig.update_layout(xaxis_title='Number of Apps (Lower = More Concentrated)',
                  yaxis_title='Number of Installs')
fig.show()

# Put in df, can just call a column (x='App'), or specify exact (y=category_df.Installs)
# size and color are parameters/data from the graph 

fig = px.scatter(category_df, x='App', 
                 y=category_df.Installs, 
                 color=category_df.Installs,
                 size=category_df.App, 
                 hover_name=category_df.index, 
                 title="Category Concentration"
                 )

fig.update_layout(xaxis_title='Number of Apps (Lower = More Concentrated)',
                  yaxis_title='Number of Installs')
fig.show()

# Linear scale isn't good for the Installs since the outliners push the majority into a cluster
# Fix it with including log-y=True, or her way: update_layout
fig = px.scatter(category_df, 
                 x='App', 
                 y='Installs', 
                 color='Installs',
                 size='App', 
                 hover_name=category_df.index,
                 log_y=True,
                 title='Category Concentration')
#Her way:
# fig.update_layout(yaxis=dict(type='log'))
fig.update_layout(xaxis_title='Number of Apps (Lower = More Concentrated)',
                  yaxis_title='Number of Installs')
fig.show()

"""# Extracting Nested Data from a Column

**Challenge**: How many different types of genres are there? Can an app belong to more than one genre? Check what happens when you use .value_counts() on a column with nested values? See if you can work around this problem by using the .split() function and the DataFrame's [.stack() method](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html). 

"""

df_cleaner.Genres.value_counts()

# The expand=True is important, it creates a new column with the split data, which is then used by the stack method to create a unique row
genre_stack = df_cleaner.Genres.str.split(";",expand=True).stack()
print(f'We now have {len(genre_stack.value_counts())} unique Genres\n')
print(genre_stack.value_counts())
genre_counts = genre_stack.value_counts()

"""# Colour Scales in Plotly Charts - Competition in Genres

**Challenge**: Can you create this chart with the Series containing the genre data? 

<img src=https://imgur.com/DbcoQli.png width=400>

Try experimenting with the built in colour scales in Plotly. You can find a full list [here](https://plotly.com/python/builtin-colorscales/). 

* Find a way to set the colour scale using the color_continuous_scale parameter. 
* Find a way to make the color axis disappear by using coloraxis_showscale.
"""

# Set the color to the value (y data) and it makes the color scale work
# Can get rid of the colorscale legend with the update_layout
bar = px.bar(x=genre_counts.index[:10], 
             y=genre_counts.values[:10], 
             color=genre_counts.values[:10],
             hover_name=genre_counts.index[:10], 
             color_continuous_scale='agsunset')

bar.update_layout(xaxis_title='Genres', 
                  yaxis_title='Number of Apps',
                  title='Top Genres',
                  coloraxis_showscale=False
                  )
bar.show()

"""# Grouped Bar Charts: Free vs. Paid Apps per Category"""

df_cleaner.Type.value_counts()

# Create new df with two groups, each with a counted value of the apps in that specific Category and Type. Brilliant!!
df_free_vs_paid = df_cleaner.groupby(['Category','Type'], as_index=False).agg({'App':pd.Series.count})
df_free_vs_paid

"""**Challenge**: Use the plotly express bar [chart examples](https://plotly.com/python/bar-charts/#bar-chart-with-sorted-or-ordered-categories) and the [.bar() API reference](https://plotly.com/python-api-reference/generated/plotly.express.bar.html#plotly.express.bar) to create this bar chart: 

<img src=https://imgur.com/LE0XCxA.png>

You'll want to use the `df_free_vs_paid` DataFrame that you created above that has the total number of free and paid apps per category. 

See if you can figure out how to get the look above by changing the `categoryorder` to 'total descending' as outlined in the documentation here [here](https://plotly.com/python/categorical-axes/#automatically-sorting-categories-by-name-or-total-value). 
"""

df = df_free_vs_paid

fig = px.histogram(df, x='Category',
                   y='App', 
                   title='Free vs. Paid Apps by Category', 
                   color='Type', 
                   barmode='group',
                   log_y=True)


fig.update_xaxes(categoryorder='total descending')

fig.update_layout(xaxis_title='Category',
                  yaxis_title='Number of Apps (Logrithmic Scale)',

                  # her way of categoryorder and log
                  # xaxis={'categoryorder':'total_descending'},
                  # yaxis=dict(type='log')
                  )

fig.show()

"""# Plotly Box Plots: Lost Downloads for Paid Apps

**Challenge**: Create a box plot that shows the number of Installs for free versus paid apps. How does the median number of installations compare? Is the difference large or small?

Use the [Box Plots Guide](https://plotly.com/python/box-plots/) and the [.box API reference](https://plotly.com/python-api-reference/generated/plotly.express.box.html) to create the following chart. 

<img src=https://imgur.com/uVsECT3.png>

"""

# Dumb way of doing it, got it reversed
df_installs_type = df_cleaner.groupby(['Installs', 'Type'], as_index=False).agg({'App':pd.Series.count})
df_installs_type

# Useless graph lol
fig = px.box(df_installs_type, x='Type', y='Installs', log_y=True, points='all')
fig.show()

# Correct way to do it
df_installs_type_2 = df_cleaner.groupby(['App', 'Type'], as_index=False).agg({'Installs':pd.Series.sum})
df_installs_type_2.sample(30)

# Useful graph
fig = px.box(df_installs_type_2, 
             x='Type', 
             y='Installs', 
             log_y=True, 
             points='all',
             color='Type',
             notched=True,
             hover_name='App',
             )
fig.update_layout(title='Installs for Free vs. Paid (Log Scale)')
fig.show()

"""# Plotly Box Plots: Revenue by App Category

**Challenge**: See if you can generate the chart below: 

<img src=https://imgur.com/v4CiNqX.png>

Looking at the hover text, how much does the median app earn in the Tools category? If developing an Android app costs $30,000 or thereabouts, does the average photography app recoup its development costs?

Hint: I've used 'min ascending' to sort the categories. 
"""

df_paid_apps = df_cleaner[df_cleaner.Type == 'Paid']

# Don't actually need to make this extra df, the df_paid_apps works for the graph
# df_paid_by_category = df_paid_apps.groupby(['App','Category'], as_index=False).agg({'Estimated_Gross':pd.Series.sum})

fig = px.box(df_paid_apps, 
             x='Category', 
             y='Estimated_Gross', 
             hover_name='App',
             log_y=True,
             )
fig.update_xaxes(categoryorder='min ascending')
fig.update_layout(title='How Much Can Paid Apps Earn',
                  xaxis_title='Category',
                  yaxis_title='Estimated Revenue')
fig.show()

"""# How Much Can You Charge? Examine Paid App Pricing Strategies by Category

**Challenge**: What is the median price price for a paid app? Then compare pricing by category by creating another box plot. But this time examine the prices (instead of the revenue estimates) of the paid apps. I recommend using `{categoryorder':'max descending'}` to sort the categories.
"""

df_paid_apps.Price.median()

fig = px.box(df_paid_apps,
             x='Category',
             y='Price',
             hover_name='App',
             title='Paid App Prices by Category',
             log_y=True)
fig.update_xaxes(categoryorder='max descending',
                 tickangle=45)
fig.update_layout(xaxis_title='Category',
                  yaxis_title='App Price')
fig.show()